### 内存管理
JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。
 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 

#### 内存生命周期
不管什么程序语言，内存生命周期基本是一致的：   
分配你所需要的内存
使用分配到的内存（读、写）
不需要时将其释放\归还

#### 值的初始化
为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。

### 垃圾回收
如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。
### object.assign

### 栈内存 跟 堆内存
基本类型
包含null、undefined、Number、String、Boolean，ES6还多了一种Symbol

基本数据类型可以直接访问，他们是按照值进行分配的，存放在栈(stack)内存中的简单数据段，“”“”数据大小确定，内存空间大小可以分配。

引用型
即Object ，是存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。

https://www.cnblogs.com/yeujuan/p/9958022.html
首先！！！！记得只有引用类型才有浅拷贝深拷贝这么 一说，s基本数据类型雨女无瓜

最常用的深拷贝：序列法和反序列法

// 序列化反序列化法
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj))
}

顾名思义，深拷贝就是完完整整的将一个对象从内存中拷贝一份出来。
所以无论用什么办法，必然绕不开开辟一块新的内存空间。
浅拷贝： 修改1处数据，会相互影响

##### 基本数据，名字 值 都存在 栈内存中
#####  当b=a 复制的时候，栈内存会开辟一个新的内存
##### 引用类型 名在栈内存中，值在堆内存，但是栈内存会提供一个引用地址指向堆内存的值。
需要层层迭代，不然对象套对象，第一层是好得。
当复制的时候，虽然在栈内存也开启新得内存，但是指向是同一个 堆内存
这不算深拷贝

因为深拷贝本身只针对较为复杂的object类型数据

通常有下面两种方法实现深拷贝：

迭代递归法
序列化反序列化法